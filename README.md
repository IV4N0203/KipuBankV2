# KipuBankV2
Contrato KipuBankV2 - IVAN ALARCON 


# KipuBankV2 - Banco Multi-Token con L√≠mite en USD

![Solidity](https://img.shields.io/badge/Solidity-0.8.26-blue)
![License](https://img.shields.io/badge/License-MIT-green)
![OpenZeppelin](https://img.shields.io/badge/OpenZeppelin-4.9.5-orange)
![Chainlink](https://img.shields.io/badge/Chainlink-Oracles-lightblue)

---

## üìå **Descripci√≥n General**
**KipuBankV2** es un contrato de banco educativo que permite a los usuarios depositar y retirar **ETH** y **tokens ERC-20**, con un **l√≠mite global de capacidad en USD** (`BANK_CAP_USD`). El contrato implementa:
- **Control de acceso** (roles para gesti√≥n de tokens, l√≠mites y pausas).
- **Pausabilidad** (para emergencias).
- **Soporte multi-token** (ETH + ERC-20).
- **Conversi√≥n a USD** (usando or√°culos de Chainlink).
- **Patr√≥n CEI** (Checks-Effects-Interactions) para seguridad.

---

## üîß **Mejoras Realizadas y Motivaci√≥n**

### **1. Seguridad**
| **Mejora**                          | **Motivo**                                                                                     | **Implementaci√≥n**                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| **Patr√≥n CEI**                      | Evitar reentrada y condiciones de carrera.                                                   | Todas las funciones siguen el orden: **Checks ‚Üí Effects ‚Üí Interactions**.         |
| **Uso de `SafeERC20`**              | Prevenir fallos en transferencias de tokens que no retornan `bool`.                           | `IERC20(token).safeTransfer(...)` en lugar de `transfer`.                         |
| **Validaci√≥n de direcciones**        | Evitar operaciones con contratos inv√°lidos o `address(0)`.                                   | `require(token.code.length > 0, "Invalid contract")`.                             |
| **Protecci√≥n contra overflow**       | Evitar desbordamientos en c√°lculos de USD.                                                    | Validaciones en `_getUsdValueFromWei` y uso de `unchecked` **solo despu√©s de checks**. |
| **Modificador `whenNotPaused`**     | Permitir pausar el contrato en emergencias.                                                  | Heredado de `Pausable` (OpenZeppelin).                                           |
| **Roles granulares**                 | Separar permisos para reducir riesgos (ej: `TOKEN_MANAGER_ROLE` vs `CAP_MANAGER_ROLE`).       | Usando `AccessControl` (OpenZeppelin).                                            |

### **2. Precisi√≥n y Conversiones**
| **Mejora**                          | **Motivo**                                                                                     | **Implementaci√≥n**                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| **Conversi√≥n Wei ‚Üí USD**             | Calcular el valor total del banco en USD para validar el l√≠mite global (`BANK_CAP_USD`).      | `_getUsdValueFromWei(weiAmount, priceUsd) ‚Üí (weiAmount * priceUsd) / 10^18`.       |
| **Decimales din√°micos**              | Soporte para tokens con diferentes decimales (ej: ETH=18, USDC=6).                           | Almacenados en `TokenData.tokenDecimals`.                                         |
| **Precisi√≥n en or√°culos**            | Usar Chainlink para precios confiables de ETH/USD.                                            | `AggregatorV3Interface` + validaci√≥n de `price > 0`.                              |

### **3. Gas Efficiency**
| **Mejora**                          | **Motivo**                                                                                     | **Implementaci√≥n**                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| **`unchecked` en aritm√©tica**        | Reducir gas en operaciones seguras (despu√©s de validaciones).                                | `unchecked { balances[user][token] += amount; }`.                                |
| **Cacheo de almacenamiento**         | Evitar m√∫ltiples lecturas de `balances`.                                                     | `uint256 userBalance = balances[msg.sender][token];`.                             |
| **Estructura `TokenData` optimizada**| Agrupar datos de tokens para reducir slots de almacenamiento.                                | `uint8 decimals` + `bool isAllowed` en el mismo slot.                             |

### **4. Usabilidad y Transparencia**
| **Mejora**                          | **Motivo**                                                                                     | **Implementaci√≥n**                                                                 |
|--------------------------------------|-----------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|
| **Eventos detallados**               | Facilitar el rastreo de operaciones (ej: dep√≥sitos, retiros).                                | `DepositSuccessful`, `WithdrawalSuccessful`, `TokenSupported`.                   |
| **Funciones de vista**               | Permitir consultar estad√≠sticas sin modificar estado.                                         | `getDepositCount()`, `getWithdrawalCount()`.                                      |
| **Mensajes de error claros**         | Ayudar a los usuarios y desarrolladores a depurar fallos.                                    | `Bank__DepositExceedsCap`, `Bank__InsufficientBalance`, etc.                      |
| **L√≠mites configurables**           | Permitir ajustar `MAX_WITHDRAWAL_PER_TX` seg√∫n necesidades.                                   | Variable `immutable` configurada en el constructor.                               |

---

## üöÄ **Despliegue e Interacci√≥n**

### **Requisitos Previos**
1. **Entorno**:
   - Node.js v18+.
   - Hardhat o Foundry.
   - Una billetera con fondos (ej: MetaMask).
   - Acceso a un or√°culo de Chainlink (ej: [ETH/USD Feed](https://data.chain.link/ethereum/mainnet/stablecoins/usdc-usd)).

2. **Dependencias**:
   ```bash
   npm install @openzeppelin/contracts @chainlink/contracts

üì• Despliegue
1. Configurar el contrato
Modifica el constructor en KipuBankV2.sol con los par√°metros deseados:

solidity
constructor(
    address priceFeedAddress,  // Ej: 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 (Chainlink ETH/USD en Sepolia)
    uint256 maxWithdrawalAmount  // Ej: 1000 * 10**18 (1000 ETH como l√≠mite por retiro)
)
2. Desplegar con Hardhat
Crea un script de despliegue (scripts/deploy.js):

javascript
const hre = require("hardhat");

async function main() {
  const [deployer] = await hre.ethers.getSigners();
  const priceFeedAddress = "0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419"; // Chainlink ETH/USD (Sepolia)
  const maxWithdrawalAmount = hre.ethers.utils.parseEther("1000"); // 1000 ETH

  const KipuBankV2 = await hre.ethers.getContractFactory("KipuBankV2");
  const bank = await KipuBankV2.deploy(priceFeedAddress, maxWithdrawalAmount);
  await bank.deployed();

  console.log("KipuBankV2 desplegado en:", bank.address);
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
Ejecuta:

bash
npx hardhat run scripts/deploy.js --network sepolia
ü§ù Interacci√≥n con el Contrato
1. Configuraci√≥n Inicial (Admin)
Agregar un token ERC-20 (ej: USDC):
javascript
await bank.addSupportedToken(
  "0x6f14C02Fc1F78322F096D7b5cD3EE6B7b5b5D553", // USDC en Sepolia
  "0x16a9FA2068be2025EC67a98EE896C5f959C4728D", // Chainlink USDC/USD
  6                                       // Decimales de USDC
);
Pausar el contrato (en emergencias):
javascript
await bank.pause();
2. Usuarios: Depositar Fondos
Depositar ETH:
javascript
await bank.deposit({ value: hre.ethers.utils.parseEther("1.0") });
Depositar ERC-20 (ej: USDC):
javascript
const usdc = await hre.ethers.getContractAt("IERC20", "0x6f14......");
await usdc.approve(bank.address, hre.ethers.utils.parseUnits("100", 6)); // Aprobar 100 USDC
await bank.depositToken(usdc.address, hre.ethers.utils.parseUnits("100", 6));
3. Usuarios: Retirar Fondos
Retirar ETH:
javascript
await bank.withdraw(hre.ethers.utils.parseEther("0.5"));
Retirar ERC-20 (ej: USDC):
javascript
await bank.withdrawToken(usdc.address, hre.ethers.utils.parseUnits("50", 6));
4. Consultar Saldos
Saldo de ETH de un usuario:
javascript
const ethBalance = await bank.balances(userAddress, "0x0000000000000000000000000000000000000000");
console.log("Saldo de ETH:", hre.ethers.utils.formatEther(ethBalance));
Saldo de USDC de un usuario:
javascript
const usdcBalance = await bank.balances(userAddress, usdc.address);
console.log("Saldo de USDC:", hre.ethers.utils.formatUnits(usdcBalance, 6));
‚öñÔ∏è Decisiones de Dise√±o y Trade-offs
1. Uso de address(0) para ETH
Decisi√≥n: Representar ETH como address(0) en el mapeo balances.
Ventajas:
Evita duplicar l√≥gica para ETH y ERC-20.
Simplifica el c√≥digo al tratar ETH como un "token especial".
Trade-offs:
Requiere validaciones adicionales para evitar confusiones (ej: require(tokenAddress != address(0), "Use deposit() for ETH")).
2. L√≠mite Global en USD (BANK_CAP_USD)
Decisi√≥n: Validar el l√≠mite de capacidad en USD (no en ETH o tokens).
Ventajas:
Permite un control m√°s preciso del riesgo (ej: 1M USD independientemente del token).
Se adapta a la volatilidad de los activos (1 ETH = $2000 hoy, pero podr√≠a valer $3000 ma√±ana).
Trade-offs:
Dependencia de or√°culos: Si el or√°culo de Chainlink falla, el contrato podr√≠a bloquearse.
Costo de gas: Cada dep√≥sito requiere una llamada a getEthPriceInUsd().
Mitigaci√≥n:
Usar un or√°culo descentralizado y confiable (ej: Chainlink).
Implementar un circuit breaker para pausar el contrato si el or√°culo falla.
3. Patr√≥n CEI (Checks-Effects-Interactions)
Decisi√≥n: Seguir estrictamente el patr√≥n CEI en todas las funciones.
Ventajas:
Previene reentrada: Al actualizar el estado antes de llamadas externas.
Claridad: C√≥digo m√°s legible y predecible.
Trade-offs:
En algunos casos, puede requerir m√°s l√≠neas de c√≥digo (ej: cachear valores antes de modificarlos).
Ejemplo:
solidity
// ‚úÖ CEI (Correcto)
function withdraw(uint256 amount) {
    // Checks: Validar saldo y l√≠mite
    require(balances[user] >= amount, "Insufficient balance");
    // Effects: Actualizar estado
    balances[user] -= amount;
    // Interactions: Llamada externa
    (bool success, ) = user.call{value: amount}("");
    require(success, "Transfer failed");
}

// ‚ùå No CEI (Riesgo de reentrada)
function withdraw(uint256 amount) {
    (bool success, ) = user.call{value: amount}(""); // Interaction primero ‚Üí Riesgo!
    require(success, "Transfer failed");
    balances[user] -= amount; // Effects despu√©s ‚Üí Vulnerable
}
4. Uso de SafeERC20
Decisi√≥n: Usar SafeERC20 para todas las transferencias de tokens.
Ventajas:
Compatibilidad: Funciona con tokens que no retornan bool en transfer (ej: USDT).
Seguridad: Evita p√©rdidas de fondos por transferencias fallidas.
Trade-offs:
Gas adicional: safeTransfer consume un poco m√°s de gas que transfer.
Justificaci√≥n:
El costo adicional es m√≠nimo comparado con el riesgo de perder fondos.
5. Roles Granulares
Decisi√≥n: Separar roles (CAP_MANAGER_ROLE, TOKEN_MANAGER_ROLE, PAUSE_MANAGER_ROLE).
Ventajas:
Principio de m√≠nimo privilegio: Cada rol tiene permisos espec√≠ficos.
Flexibilidad: Permite asignar responsabilidades a diferentes equipos (ej: un equipo gestiona tokens, otro gestiona l√≠mites).
Trade-offs:
Complejidad: M√°s roles = m√°s gesti√≥n de permisos.
Recomendaci√≥n:
En producci√≥n, asignar roles a multisigs o contratos de timelock (no a EOAs).
6. unchecked para Optimizaci√≥n de Gas
Decisi√≥n: Usar unchecked en operaciones aritm√©ticas despu√©s de validaciones.
Ventajas:
Reducci√≥n de gas: Evita checks de overflow/underflow cuando no son necesarios.
Trade-offs:
Riesgo de bugs: Si las validaciones son incorrectas, podr√≠a haber overflows.
Regla aplicada:
Solo se usa unchecked despu√©s de verificar que no habr√° overflow (ej: require(a + b > a, "Overflow")).
üö® Advertencias de Seguridad
No usar en producci√≥n:

Este contrato es educativo y no ha sido auditado. Contiene riesgos como:
Dependencia de un solo or√°culo (Chainlink).
Falta de protecci√≥n contra front-running en operaciones cr√≠ticas.
Posible centralizaci√≥n si los roles se asignan a una sola EOA.
Riesgos conocidos:

Oracle manipulation: Un atacante podr√≠a manipular el precio de ETH/USD para burlar BANK_CAP_USD.
Reentrada en tokens ERC-777: SafeERC20 no protege contra tokens ERC-777 maliciosos. Usar nonReentrant en funciones cr√≠ticas.
P√©rdida de fondos: Si el or√°culo falla, el contrato podr√≠a quedar inutilizable.
Recomendaciones para producci√≥n:

Usar un or√°culo descentralizado (ej: Chainlink + fallback).
Implementar l√≠mite de tiempo para pausas (evitar pausas indefinidas).
A√±adir funci√≥n de rescate (emergencyWithdraw) para casos extremos.
Auditar el contrato con herramientas como Slither, MythX o CertiK.
üìö Recursos Adicionales
Documentaci√≥n de OpenZeppelin
Chainlink Price Feeds
Patr√≥n CEI (Checks-Effects-Interactions)
SafeERC20: Por qu√© usarlo

